<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0066)lec5.htm -->
<HTML><HEAD><TITLE>Логическое и функциональное программирование. Лекция 5</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 aLink=#0000ff bgColor=#c7d4ea>
<P><FONT face="Arial Cyr">
<TABLE cellSpacing=0 width="100%" align=center border=0>
  <TBODY>
  <TR><!-- Row 1 -->
    <TD width=10 bgColor=#8181c0>
    <TD vAlign=center align=left width="65%" bgColor=#8181c0><FONT
      color=#c6c6ff size=4><B><I>Лекция 5</I></B></FONT>
    <TD bgColor=#c7d4ea>
    <TD bgColor=#c7d4ea></TD>
  <TR><!-- Row 2 -->
    <TD width=10 bgColor=#a3a3d1><FONT color=#8181c9></FONT>
    <TD vAlign=center align=middle width="65%" bgColor=#a3a3d1 height=20><FONT
      color=#004080 size=5><B><I>Отсечение. Сортировка списков.</I></B> </FONT>
    <TD bgColor=#c7d4ea>
    <TD bgColor=#c7d4ea></TD></TR></TBODY></TABLE></FONT>
<CENTER></CENTER><FONT face="Arial Cyr">
<H2><FONT face="Arial Cyr" color=#004080>Cодержание</FONT></H2>
<DL>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.1">5.1
  Отсечение.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.1.1">5.1.1
  Графическая иллюстрация действия cut.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.1.2">5.1.2
  Пример действия cut.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.1.3">5.1.3
  Применение cut при выборе альтернатив.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.1.4">5.1.4
  Формальное описание действия отсечения.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.2">5.2
  Применение отсечения.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.2.1">5.2.1
  minimum(X, Y, M).</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.2.2">5.2.2
  Добавление элемента без дублирования.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.2.3">5.2.3
  Классификация.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.2.4">5.2.4
  Отсечение в численной рекурсии.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.2.5">5.2.5
  Замечания при использовании отсечения.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.3">5.3
  Сортировка списков.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.3.1">5.3.1
  Метод наивной сортировки.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.3.2">5.3.2
  Метод пузырька.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.3.3">5.3.3
  Mетод вставки.</A>
  <DD><IMG src="lec5.files/blueball.gif"> <A
  href="lec5.htm#Lec5.3.4">5.3.4
  Быстрая сортировка quick.</A> </DD></DL></FONT>
<P align=center><FONT face="Arial Cyr"><IMG height=8 src="lec5.files/saqual.gif"
width="90%"></FONT></P>
<P><FONT face="Arial Cyr"><A name=Lec5.1>
<CENTER>
<H2><FONT color=#000080>5.1 Отсечение.</H2></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=8 src="lec5.files/saqual.gif"
width="90%"></FONT></P>
<P>В процессе вычисления цели пролог проводит перебор вариантов, в соответствии
с установленным порядком. Цели выполняются последовательно, одна за другой, а в
случае неудачи происходит <FONT color=#800080><B>откат<BR>к предыдущей цели
(backtracing).</B></FONT>
<P>Однако для повышения эффективности выполнения программы, часто требуется
вмешаться в перебор, ограничить его, исключить некоторые цели.
<P>Для этой цели в пролог введена специальная конструкция <FONT
color=#800080><B>cut - "отсечение"</B></FONT>, обозначаемая как <B>"!"</B> <BR>(
Читается <B>"cut", "кат"</B>).
<P><IMG src="lec5.files/deistvie.gif">
<P><B>Cut</B> подсказывает прологу "закрепить" все решения предшествующие
появлению его в предложении. Это означает, что если требуется бэктрекинг, то он
приведет к неудаче (<B>fail</B>) без попытки поиска альтернатив.
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.1.1>
<CENTER>
<H3><FONT color=#000080>5.1.1 Графическая иллюстрация действия
cut.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Графически действие <B>cut</B> можно показать с помощью <FONT
color=#800080><B>box-представления</B></FONT> логического вывода.
<P>В обычном случае бэктрекинг для правила
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>G:-A,B,C.</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>выглядит следующим образом:
<P><IMG src="lec5.files/cut_gr1.gif">
<P>Т.е. поиск альтернатив производится для всех целей: <B>G,A,B,C.</B> Заменим
<B>B</B> на <B>cut</B> :
<P><IMG src="lec5.files/cut_gr2.gif">
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=middle colSpan=2><A
      href="GRAF_CUT.FLI"><IMG
      alt="" src="lec5.files/ani.gif" border=0 SPACE="20"></IMG></A>
    <TD align=TOP>Графическая иллюстрация действия cut.</TD>
    <TD align=left></A>
      <P></A></P></TD></TD></TR></TBODY></TABLE>Действие cut заключается в отмене
поиска альтернатив для целей <B>A,G</B>, стоящих после <B>"!"</B>.
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P><A name=Lec5.1.2>
<CENTER>
<H3><FONT color=#000080>5.1.2 Пример действия cut.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Пусть база данных выглядит следующим
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>data(one). <BR>data(two). <BR>data(three).</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>Процедура для проверки:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>cut_test_a(X):- data(X). <BR>cut_test_a('last
      clouse').</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>Цель:
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2 rowSpan=0><IMG alt=""
      src="lec5.files/COMPUT.gif" align=top border=0 SPACE="0"></IMG>
    <TD align=left><B><FONT color=#800010>?- </FONT>cut_test_a(X),nl,write(X).
      <BR>one; <BR>two; <BR>three; <BR>last_clouse; <BR>no</B> </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>Теперь поставим <B>cut</B> в правило:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>cut_test_b(X):- data(X),!. <BR>cut_test_b('last
      clouse').</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>Цель:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>cut_test_b(X),nl,write(X).
      <BR>one; <BR>no</B> </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>Происходит остановка бэктрекинга для левого <B>data</B> и родительского
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>cut_test_b(X).</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>Теперь поместим <B>cut</B> между двумя целями.
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>cut_test_с(X,Y):- data(X), <BR>/ !,data(Y).
      <BR>cut_test_с('last clouse').</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>Теперь бэктрекинг не будет для для левого <B>data</B> и родительского
<B>cut_test_b(X)</B>,но будет для правого <B>data</B>,стоящего после<B> !</B>.
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT
      color=#800010>?-</FONT>cut_test_с(X,Y),nl,write(X-Y). <BR>one-one;
      <BR>one-two; <BR>one-tree; <BR>no</B> </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.1.3>
<CENTER>
<H3><FONT color=#000080>5.1.3 Применение cut при выборе
альтернатив.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Рассмотрим функцию<B> Y(X)</B>:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><BR><B><PRE>         /
         ?  0 ,   X &lt; 3
         ?
  Y= &lt;   2 ,  3 = &lt; X &lt; 6
         ?
         ?  4 ,  X &gt;= 6
         \
</PRE></B><BR>
    <TD align=left><IMG alt="" src="lec5.files/fun.gif" border=0
      SPACE="20"></IMG>
      <P></A></P></TD></TD>
  <TR></TR></TBODY></TABLE>На прологе это запишется через бинарное отношение
<B>f(X, Y).</B>
<P>Процедура выглядит:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>f(X, 0):- X &lt; 3. <BR>f(X, 2):- 3 =&lt; X, X &lt; 6.
      <BR>f(X, 4):- 6 =&lt; X.</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>Зададим вопрос: <BR>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>f(1,Y),Y&gt;2.
    </A></B></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>Таким образом последовательно проверяются все три предложения, хотя сразу
ясно, что выполняется только одно. <BR><FONT color=#800080><B>Как убрать
неэффективность?</B></FONT> <BR>Надо использовать отсечение-<B>cut.</B>
<BR>Перепишем
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>f( X, 0):-X&lt;3, !. <BR>f(X, 2):- 3=&lt;X, X&lt;6, !.
      <BR>f(X, 4):-6 =&lt;X, !.</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>! указывает, что возврат из этой точки проводить не надо.
<P>Что произойдет теперь? <BR>Для цели
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>f(1, Y), Y&gt;2. <BR>no</B>
      </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>После выполнения цели <B>X&lt;3</B> цель <B>Y&gt;2</B>, не достигается, но
откат не может произойти, так как стоит <B>cut</B>.
<P>Таким образом сокращается перебор.
<P>Аналогично для цели
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>f(5, Y), Y=0.</B>
    </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>Здесь введение <B>cut</B> повышает эффективность программы, сокращая время
перебора и объем памяти, не влияет на декларативное чтение программы.
<P>После изъятия <B>!</B> декларативный смысл не изменится.
<P>Такое применение <B>cut</B> называют <FONT color=#800080><B>"зеленым
отсечением".</B></FONT>
<P><B>"Зеленые отсечения"</B> лишь отбрасывают те пути вычисления, которые не
приводят к новым решениям.
<P><IMG src="lec5.files/greencut.gif">
<P>Бывают и <FONT color=#800080><B>"красные отсечения"</B></FONT>, при изъятии
которых меняется декларативный смысл программы.
<P><IMG src="lec5.files/redcut.gif">
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.1.4>
<CENTER>
<H3><FONT color=#000080>5.1.4 Формальное описание действия
отсечения.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Рассмотрим предложение
<P><B>Н:-B1, B2,..., Bm, !,..., Bn.</B>
<P>Это предложение активизируется, когда некоторая цель <B>G</B>, будет
сопоставляться с <B>H</B>.
<P>Тогда <B>G</B> называют <FONT color=#800080><B>целью-родителем</B></FONT>.
<P>Если <B>B1, B2,..., Bm</B> выполнены, а после <B>!</B>, например в <B>Bi,
i&gt;m</B>, произошла неудача и требуется выбрать альтернативные варианты, то
для <B>B1, B2,..., Bm</B> такие альтернативы больше не рассматриваются и все
выполнение окончится неудачей. Кроме этого <B>G</B> будет связана с головой
<B>H</B>, и другие предложения процедуры во внимание не принимаются.
<P>Т.е. отсечение в теле предложения отбрасывает все предложения , расположенные
после этого предложения.
<P><IMG src="lec5.files/opisanie.gif">
<P>Формально действие отсечения описывается так:
<P>Пусть цель -родитель сопоставляется с головой предложения, в теле которого
содержится отсечение.
<P>Когда при просмотре целей тела предложения встречается в качестве цели
отсечение, то такая цель считается успешной и все альтернативы принятым решениям
до отсечения отбрасываются и любая попытка найти новые альтернативы на
промежутке между целью-родителем и <B>сut</B> оканчиваются неудачей. <BR>Процесс
поиска возвращается к последнему выбору, сделанному перед сопоставлением цели
родителя.
<P align=center><FONT face="Arial Cyr"><IMG height=8 src="lec5.files/saqual.gif"
width="90%"></FONT></P>
<P><A name=Lec5.2>
<CENTER>
<H2><FONT color=#000080>5.2 Применение отсечения.</H2></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=8 src="lec5.files/saqual.gif"
width="90%"></FONT></P>
<P><A name=Lec5.2.1>
<CENTER>
<H3><FONT color=#000080>5.2.1 minimum(X, Y, M).</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Найти минимальный элемент из двух.
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>minimum(X, Y, X):- X&lt;=Y, !.<BR>minimum(X, Y, Y):-
      Y<X, B !.<>
      <P></A></P></B></TD></TD></TR></TBODY></TABLE><BR>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>minimum(2, 5,
      Y).<BR></B></A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P><IMG src="lec5.files/minimum.gif">
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.2.2>
<CENTER>
<H3><FONT color=#000080>5.2.2 Добавление элемента без
дублирования.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Чтобы добавить элемент в голову списка достаточно использовать
<P><B>add(X, L, [X|L]).</B>
<P>Но если возникает необходимость добавлять только, если элемент отсутствует,
то можно добавить правило:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>add(X, L, L):-member(X, L), !. add(X, L, [X|L]).</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P><IMG src="lec5.files/add.gif">
<P>Вопрос
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>add(a, [b, c], L).
      <BR>L=[a, b, c] <BR><FONT color=#800010>?-</FONT>add(b, [b, c], L).
      <BR>L=[b, c]</B> </B></A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>Если сечение убрать, то
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>add(b, [b, c], L) <BR>L=[b,
      c]; <BR>L=[b, b, c]</B> </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P>Таким образом, при изъятии отсечения, изменился декларативный смысл
программы- отсечение <B>"красное"</B>.
<P><A name=Lec5.2.3>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>
<H3 align=center><FONT color=#000080>5.2.3 Классификация.</H3></A></FONT>
<CENTER></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Используя отсечение, легко произвести классификацию объектов.
<P>Например, надо классифицировать числа
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>class(X, plus):-X&gt;0, !. <BR>class(X, minus):-X&lt;0,
      !. <BR>class(X, zero):-X=0, !.</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE><BR>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><IMG alt="" src="lec5.files/COMPUT.gif" border=0
      SPACE="20"></IMG>
      <P></P>
    <TD align=left><B><FONT color=#800010>?-</FONT>class(4, Y). <BR>Y=plus</B>
      </A></TD></TD>
  <TR></TR></TBODY></TABLE>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.2.4>
<CENTER>
<H3><FONT color=#000080>5.2.4 Отсечение в численной
рекурсии.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Применение отсечения в рекурсии позволяет значительно сократить использование
памяти.
<P>Определим факториал
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>factorial(0, 1):-!. <BR>factorial(N, RES) :- <BR>N1 is
      N-1, factorial(N1, N1fak), Res is N*N1fak.</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.2.5>
<CENTER>
<H3><FONT color=#000080>5.2.5 Замечания при использовании
отсечения.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>Применение сечения за счет сокращения перебора позволяет повысить
эффективность программы. Кроме этого отсечение упрощает программирование выбора
вариантов.
<P>Вместе с тем, часто, при использовании красных отсечений может изменится
декларативный смысл программы.
<P><IMG src="lec5.files/zamech.gif">
<P>Поэтому отсечение требует осторожности в использовании.
<P>Следует избегать<FONT color=#800080><B> двух ошибок</B></FONT>:
<P>
<UL>
  <LI>отсечения путей вычисления, которые нельзя отбрасывать
  <LI>и не отсечения тех решений, которые должны были быть отброшены. </LI></UL>
<P>
<P align=center><FONT face="Arial Cyr"><IMG height=8 src="lec5.files/saqual.gif"
width="90%"></FONT></P>
<P><A name=Lec5.3>
<CENTER>
<H2><FONT color=#000080>5.3 Сортировка списков.</H2></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=8 src="lec5.files/saqual.gif"
width="90%"></FONT></P>
<P>До сих пор средства пролога использовались при записи простых процедур и
примеров. Рассмотрим более сложные примеры написания программ на прологе для
различных методов сортировки. <A name=Lec5.3.1>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>
<H3 align=center><FONT color=#000080>5.3.1 Метод наивной
сортировки.</H3></A></FONT>
<CENTER></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>В этом методе элементы в списке переставляются ( перемешиваются
<B>permutation/2</B> ),и проверяется отсортирован этот список или нет:
<B>sorted/1.</B> <BR>Это записывается:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>sortn(L1, L2) :- permutation(L1, L2), sorted(L2), !.</B>

      <P></A></P></TD></TD></TR></TBODY></TABLE>Перестановки определим через
<B>append</B>
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!--IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>permutation(L, [H|T]) :- append(V, [H|U], L),
      <BR>append(V, U, W), <BR>permutation(W, T). <BR>permutation([], []).</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>Проверка того, что элементы списка
расположены в возрастающем порядке выражается через два предложения. Факт
означает, что список из одного элемента всегда упорядочен. Правило утверждает,
что список упорядочен ,если первые два элемента расположены по порядку и остаток
,начинающийся со второго элемента тоже упорядочен:
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>sorted([L]). <BR>sorted([X,Y|T]) :- order(X,Y),
      sorted([Y|T]). <BR>order(X, Y) :- X =&lt; Y. </B>
      <P></A></P></TD></TD></TR></TBODY></TABLE>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.3.2>
<CENTER>
<H3><FONT color=#000080>5.3.2 Метод пузырька.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><IMG src="lec5.files/puzir.gif">
<P>Это простой и эффективный метод.
<P><FONT color=#800080><B>Декларативное описание:</B></FONT>
<P>
<OL>
  <LI>Найти в списке <B>L</B> два смежных элемента <B>X</B> и <B>Y</B>, таких,
  что <B>X &gt; Y</B>, поменять их местами и получить новый список, <B>M</B>,
  затем отсортировать <B>M</B>. Для поиска таких элементов и перестановки
  используется процедура <B>swap/2</B>.
  <LI>Если в списке нет не одной пары смежных элемента <B>X</B> и<B> Y</B>,
  таких, что <B>X &gt; Y</B>, считать что список отсортирован. </LI></OL>
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B>busort(L, S) :- swap(L, M), !, busort(M, S).
      <BR>busort(L, L) :- !. <BR>swap([X, Y|R], [Y, X|R]) :- order(Y, X).
      <BR>swap([X|R], [X|R1]) :- swap(R, R1).</B>
      <P></A></P></TD></TD></TR></TBODY></TABLE><A name=Lec5.3.3>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P>
<H3 align=center><FONT color=#000080>5.3.3 Mетод вставки.</H3></A></FONT>
<CENTER></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><IMG src="lec5.files/vstavka.gif">
<P><FONT color=#800080><B>Декларативное описание:</B></FONT>
<P>Для того чтобы упорядочить непустой список <B>L=[X|T] </B>необходимо:
<OL>
  <LI>Упорядочить хвост <B>Т</B> списка <B>L</B>
  <LI>Вставить голову <B>X</B> списка <B>L</B> в упорядоченный хвост, поместив
  ее таким образом, чтобы получившийся список остался упорядоченным. </LI></OL>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
      <P></P>
    <TD align=left><B><FONT face="Arial Cyr" size=+2><PRE><B>    insort([], []).
<BR>    insort([X|L], M) :- insort(L, N), insortx(X, N, M).
<BR>    insortx(X, [A|L], [A|M]) :- order(A, X), !, insortx(X, L, M).
<BR>    insortx(X, L, [X|L]).
<BR>    order(X, Y) :- X =&lt; Y.</B>
</PRE></A></FONT></B></TD></TD></TR></TBODY></TABLE></FONT>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><A name=Lec5.3.4>
<CENTER>
<H3><FONT color=#000080>5.3.4 Быстрая сортировка quick.</H3></A></FONT></CENTER>
<P align=center><FONT face="Arial Cyr"><IMG height=5 src="lec5.files/saqual.gif"
width="70%"></FONT></P>
<P><FONT face="Arial Cyr"><FONT color=#800080><B>Описание метода:</B></FONT>
<P>Убираем первый элемент: <PRE><FONT face="Arial Cyr" size=+2>
     <B>    5 3 7 8 1 4 7 6</B>
</PRE></FONT>получаем:<B> X =5.</B> <BR>и оставшийся список: <PRE><FONT face="Arial Cyr" size=+2>
   <B>      3 7 8 1 4 7 6</B>
</PRE></FONT>Разбиваем новый список на два, помещая в первый элементы меньше
<B>X</B>, а во второй - больше <B>X</B>: <PRE><FONT face="Arial Cyr" size=+2>
<B>  ( X: 3 1 4  )  X:  7 8 7 6</B>
</PRE></FONT>Сортируем оба списка: <PRE><FONT face="Arial Cyr" size=+2>
<B>   1 3 4        6 7 7 8</B>
</PRE></FONT>Соединим первый список,<B> X</B>, второй список. <PRE><FONT face="Arial Cyr" size=+2>
<B>      1 3 4 5 6 7 7 8</B>
</PRE></FONT><BR><FONT face="Arial Cyr"><FONT color=#800080><B>Декларативное
описание:</B></FONT></FONT>
<P>
<OL>
  <LI>Удалить из списка голову <B>Х</B> и разбить оставшийся список на два
  списка <B>Small</B> и <B>Big</B> следующим образом: все элементы большие чем
  <B>Х</B> помещаются в <B>Big</B> и меньшие <B>X</B> - в <B>Small</B>.
  <LI>Отсортировать список <B>Small</B> в <B>Small1</B>.
  <LI>Отсортировать список <B>Big</B> в <B>Big1</B>.
  <LI>Соединить списки <B>Small1 Х</B> и <B>Big1</B>. </LI></OL>
<P>
<TABLE width=600 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=TOP colSpan=2><!-- IMG SRC="yellow.gif"  ALT="" BORDER=0 SPACE=20></IMG -->
    <TD align=left><B><PRE><FONT face="Arial Cyr" size=+1>
qsort([], []).
qsort([H|Tail], S) :- split(H, Tail, Small, Big),
                           qsort(Small, Small1),
                           qsort(Big, Big1),
                           append(Small1, [H|Big1], S).

order(X, Y) :- X =&lt; Y.
split(H, [A|Tail], [A|Small], Big) :- order(A, H), !,
                                               split(H, Tail, Small, Big).
split(H, [A|Tail], Small, [A|Big]) :- split(H, Tail, Small, Big).
split(_, [], [], []).</B>
</PRE></FONT></A></TD></TD></TR></TBODY></TABLE></FONT></FONT></FONT>
<CENTER>
<P>
<HR align=left width="75%" noShade SIZE=1>
</BODY></HTML>